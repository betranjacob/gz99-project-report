\documentclass[../../../main.tex]{subfiles}

\begin{document}
\label{sec:endtoend}
We conducted this analysis to uncover the impact of our design and
additional SGX instructions on the end-to-end web server performance.
To this end, we used the \enclavemodel, while varying the
number of busywait cycles, to approximate the overhead of SGX
instructions. Additionally, we evaluated the effect of the response
size on the end-to-end performance by varying the size of the response
to a client's request.

\subsubsection*{Test Setup}
We run our tests on two Amazon EC2 m4.large instances, one for the
server and the other for the client, located on different virtual
machines within the same data center. These machines are comprised of
2 virtual CPUs with 8 GB RAM and and, according to \textit{iperf} (a
network diagnostics tool), the network bandwidth between the two
machines was 500 Mbits/s. The underlying hardware is an Intel Xeon
E5-2676 v3 clocked @ 2.4 GHz with 30MB of CPU cache
\cite{aws_instances}, running Ubuntu 14.04 with kernel version
4.4.0-34-generic. We used \Apache~Benchmark to generate 5000 HTTPS
requests across 10 concurrent connections and measured the performance
of the server. We consider the following four scenarios:
\begin{enumerate}
  \item Using a cipher lacking support for forward secrecy, AES256-GCM-SHA384,
    with the design where session keys reside \textbf{outside} the trusted
    component
  \item Using a cipher lacking support for forward secrecy, AES256-GCM-SHA384,
    with the design where session keys reside \textbf{inside} the trusted
    component
  \item Using a cipher offering support for forward secrecy,
    ECDHE-RSA-AES256-GCM-SHA384, with the design where session keys reside
    \textbf{outside} the trusted component
  \item Using a cipher offering support for forward secrecy,
    ECDHE-RSA-AES256-GCM-SHA384, with the design where session keys reside
    \textbf{inside} the trusted component
\end{enumerate}

For each of the above scenarios we run the test while varying the
number of busywait cycles from 0 to 50,000 and keeping the response
size constant at 1 KB. Next, we removed the busywaits and varied the
response sizes from 1 KB to 4 MB. We setup NGINX with a single worker
process due to the limitations mentioned in Section
\ref{sec:implementation}.

\subsubsection*{Results}
Figure \ref{fig:cycles-requests} displays the server responses/s for
varying number of busywait cycles. Figure \ref{fig:sizreqs}
demonstrates the server responses/s for variable response size and
zero number of busywait cycles. Note the logscale on the x-axis. Each
point on the plot is for a response double the size of the previous
point's.
\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[pretty,ylabel = Responses/Second, ymin = 0, xlabel =
        Number Of Busywait Cycles ($10^4$), legend pos=outer
        north east, xtick scale label code/.code = {}]
      \addplot[color=red] table[y=Stock RSA] from \cyclereqs;
      \addlegendentry{Stock \textit{RSA}};
      \addplot[color=red, mark=square*] table[y=Key Outside RSA] from \cyclereqs;
      \addlegendentry{Session Keys Outside \textit{RSA}};
      \addplot[color=red, mark=*] table[y=Key Inside RSA] from \cyclereqs;
      \addlegendentry{Session Keys Inside \textit{RSA}};

      \addplot[color=blue] table[y=Stock ECDHE] from \cyclereqs;
      \addlegendentry{Stock \textit{ECDHE}};
      \addplot[color=blue, mark=square*] table[y=Key Outside ECDHE] from \cyclereqs;
      \addlegendentry{Session Keys Outside \textit{ECDHE}};
      \addplot[color=blue, mark=*] table[y=Key Inside ECDHE] from \cyclereqs;
      \addlegendentry{Session Keys Inside \textit{ECDHE}};
    \end{axis}
  \end{tikzpicture}
  \caption{Requests per second vs. busywait cycles}
  \label{fig:cycles-requests}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[title/.style = {font=\bfseries, align=center}]
    \begin{axis}[pretty,ylabel = Responses/Second, ymin = 0, xmode =
      log, log basis x = {2},xlabel = Response Size (KB), legend
      pos=outer north east, xtick scale label code/.code = {}]
      \addplot[color=red, mark=+] table[y=Stock RSA] from \sizereqs;
      \addlegendentry{Stock \textit{RSA}};
      \addplot[color=red, mark=square*] table[y=Key Outside RSA] from \sizereqs;
      \addlegendentry{Session Keys Outside \textit{RSA}};
      \addplot[color=red, mark=*] table[y=Key Inside RSA] from \sizereqs;
      \addlegendentry{Session Keys Inside \textit{RSA}};

      \addplot[color=blue, mark=+] table[y=Stock ECDHE] from \sizereqs;
      \addlegendentry{Stock \textit{ECDHE}};
      \addplot[color=blue, mark=square*] table[y=Key Outside ECDHE] from \sizereqs;
      \addlegendentry{Session Keys Outside \textit{ECDHE}};
      \addplot[color=blue, mark=*] table[y=Key Inside ECDHE] from \sizereqs;
      \addlegendentry{Session Keys Inside \textit{ECDHE}};
   \end{axis}
  \end{tikzpicture}
  \caption{Requests per second vs. response size}
  \label{fig:sizreqs}
\end{figure}

\subsubsection*{Analysis of Figure~\ref{fig:cycles-requests}}
As discussed in Section \ref{sec:cpu-instr-analysis}, we add an
overhead of \textasciitilde15\% in additional instructions. This,
however, does not account for the total overhead we observe in
Figure~\ref{fig:cycle-requests} when the number of busywait cycles is
set to 0. The remaining overhead is a result of context switches.

Every invocation of ERESUME and EEXIT implies switching from the
\textit{enclave program} to the untrusted component and from the
untrusted component to the \textit{enclave program} respectively. A
context switch causes a TLB flush, which in turn results in slower
execution until the TLB is repopulated. This is emulated in our
\enclavemodel~ by the system calls \texttt{read()}/\texttt{write()}
which are used to communicated via the named pipe.

From Section~\ref{sec:cpu-instr-analysis} we see that the number of
context switches are as follows:
\begin{itemize}
  \item 12200 context switches per second, in
    the case of ciphers lacking forward secrecy, where session keys are
    outside the enclave
  \item 11046 context switches per second, in the case of ciphers offering
    forward secrecy and session keys are outside the enclave
  \item 38164 context switches per second, in the case of ciphers lacking
    forward secrecy and session keys are inside the enclave
  \item 26510 context switches per second, in the case of ciphers offering
    forward secrecy and session keys are inside the enclave
\end{itemize}

The overhead for the various scenarios when compard to the stock implementation is
as follows:
\begin{itemize}
  \item Session keys outside \textit{RSA} is 19\%, leaving 4\%
    attributed to context switching
  \item Session keys inside \textit{RSA} is 30\%, leaving 15\%
    attributed to context switches
  \item Session keys outside \textit{ECDHE} is 29\%, leaving 13\%
    attributed to context switches
  \item Session keys inside \textit{ECDHE} is 37\%, leaving 21\%
    attributed to context switches
\end{itemize}

\subsubsection*{Analysis of Figure~\ref{fig:sizreqs}}
As the response size increases, we expect to see slight degradation in
the performance of the prototype where session keys are held inside
the enclave because the payload has to be copied from the untrusted
componenet to the \textit{enclave program}. Since this cost is not
incured by the prototype where session keys are outisde, we do not
expect to see that penalty.

From Figure~\ref{fig:sizreqs}, we see that, for session keys outside,
the line is flatter than for session keys inside confirming our
hypothesis. Yet, the performance of our prototype and the stock
implementation begins to decrease significantly for as we increase
response size past 128 KB. This is due to the network becoming
saturated with outgoing responses. The network bandwidth on the
machine we used is approximately 560Mb/sec which is 70MB/sec. At 128
KB, the stock implementation creates 500 responses/sec, sending 64
MB/sec to clients which is very close to the maximum link capacity.
Since our prototype generates a lesser number of requests in
comparison to the stock implementations, this also explains why the
decrease is not as fast, initially, for our prototype. 

% TODO: document keys inside/outside for the first graph TODO:
% document the second graph
\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../../main"
%%% End:
