\documentclass[../../../main.tex]{subfiles}

\begin{document}
\label{sec:endtoend}
We conducted this analysis to uncover the impact of our design and additional SGX instructions on the end-to-end web server performance. To this end, we
utilised the performance model, while varying the number of busywait
cycles, to approximate the overhead of SGX instructions. Additionally,
we evaluated the effect of the response size on the end-to-end performance by
varying the size of the response to a client's request.

\subsubsection*{Test Setup}
We run our tests on two Amazon EC2 m4.large instances, one for the
server and the other for the client, located on different virtual
machines within the same data center. These machines are comprised of
2 virtual CPUs with 8 GB RAM and and, according to \textit{iperf} (a
network diagnostics tool), the network bandwidth between the two
machines was 500 Mbits/s. The underlying hardware is an Intel Xeon
E5-2676 v3 clocked @ 2.4 GHz with 30MB of CPU cache
\cite{aws_instances}, running Ubuntu 14.04 with kernel version
4.4.0-34-generic. We used \Apache~Benchmark to generate 5000 HTTPS
requests across 10 concurrent connections and measured the performance
of the server. We consider the following four scenarios:
\begin{enumerate}
  \item Using a cipher lacking support for forward secrecy, AES256-GCM-SHA384,
    with the design where session keys reside \textbf{outside} the trusted
    component
  \item Using a cipher lacking support for forward secrecy, AES256-GCM-SHA384,
    with the design where session keys reside \textbf{inside} the trusted
    component
  \item Using a cipher offering support for forward secrecy,
    ECDHE-RSA-AES256-GCM-SHA384, with the design where session keys reside
    \textbf{outside} the trusted component
  \item Using a cipher offering support for forward secrecy,
    ECDHE-RSA-AES256-GCM-SHA384, with the design where session keys reside
    \textbf{inside} the trusted component
\end{enumerate}

For each of the above scenarios we run the test for a variable number
of busywait cycles from 0 to 50,000 while keeping the response size constant at 1 KB. Next we removed the busywaits and varied the response sizes from 1 KB to 4 MB. We setup NGINX with a single worker process due to the
limitations mentioned in Section \ref{sec:implementation}.

\subsubsection*{Results}
Figure \ref{fig:cycles-requests} displays the server responses/s for
varying number of busywait cycles. Figure \ref{fig:sizreqs}
demonstrates the server responses/s for variable response size and
zero number of busywait cycles. Note that each point represents a response double the size of the previous point and the logscale on the x axis.
\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[pretty,ylabel = Responses/Second, ymin = 0, xlabel =
        Number Of Busywait Cycles (Cycles * $10^4$), legend pos=outer
        north east, xtick scale label code/.code = {}]
      \addplot[color=red] table[y=Stock RSA] from \cyclereqs;
      \addlegendentry{Stock \textit{RSA}};
      \addplot[color=red, mark=square*] table[y=Key Outside RSA] from \cyclereqs;
      \addlegendentry{Session Keys Outside \textit{RSA}};
      \addplot[color=red, mark=*] table[y=Key Inside RSA] from \cyclereqs;
      \addlegendentry{Session Keys Inside \textit{RSA}};

      \addplot[color=blue] table[y=Stock ECDHE] from \cyclereqs;
      \addlegendentry{Stock \textit{ECDHE}};
      \addplot[color=blue, mark=square*] table[y=Key Outside ECDHE] from \cyclereqs;
      \addlegendentry{Session Keys Outside \textit{ECDHE}};
      \addplot[color=blue, mark=*] table[y=Key Inside ECDHE] from \cyclereqs;
      \addlegendentry{Session Keys Inside \textit{ECDHE}};
    \end{axis}
  \end{tikzpicture}
  \caption{Rrequests per second vs. busywait cycles}
  \label{fig:cycles-requests}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[title/.style = {font=\bfseries, align=center}]
    \begin{axis}[pretty,ylabel = Responses/Second, ymin = 0, xmode =
        log,xlabel = Response Size (KB), legend pos=outer north east,
        xtick scale label code/.code = {}]
      \addplot[color=red, mark=+] table[y=Stock RSA] from \sizereqs;
      \addlegendentry{Stock \textit{RSA}};
      \addplot[color=red, mark=square*] table[y=Key Outside RSA] from \sizereqs;
      \addlegendentry{Session Keys Outside \textit{RSA}};
      \addplot[color=red, mark=*] table[y=Key Inside RSA] from \sizereqs;
      \addlegendentry{Session Keys Inside \textit{RSA}};

      \addplot[color=blue, mark=+] table[y=Stock ECDHE] from \sizereqs;
      \addlegendentry{Stock \textit{ECDHE}};
      \addplot[color=blue, mark=square*] table[y=Key Outside ECDHE] from \sizereqs;
      \addlegendentry{Session Keys Outside \textit{ECDHE}};
      \addplot[color=blue, mark=*] table[y=Key Inside ECDHE] from \sizereqs;
      \addlegendentry{Session Keys Inside \textit{ECDHE}};
   \end{axis}
  \end{tikzpicture}
  \caption{Requests per second vs. response size}
  \label{fig:sizreqs}
\end{figure}

\subsubsection*{Analysis}
As discussed in Section \ref{sec:cpu-instr-analysis}:
\begin{itemize}
  \item 13 invocations of ERESUME/EEXIT pair occur, per request, in
    the case of ciphers lacking forward secrecy, where session keys are
    outside the enclave
  \item 21 invocations, per request, in the case of ciphers offering
    forward secrecy and session keys are outside the enclave
  \item 47 invocations, per request, in the case of ciphers lacking
    forward secrecy and session keys are inside the enclave
  \item 55 invocations, per request, in the case of ciphers offering
    forward secrecy and session keys are inside the enclave
\end{itemize}
We expected the performance penalty to be around 15\%, because each
context switch causes a TLB flush, which in turn results in slower
execution until the TLB is repopulated. Figure
\ref{fig:cycles-requests} validates our hypothesis. It shows a
performance penalty of \textasciitilde18\% for RSA ciphers and
\textasciitilde33\% for ECDHE ciphers. Note that, the performance
degradation between the two isolation scenarios is not linear, as one
might expect by only observing the increase in the number of context
switches (+28\%). The overhead is actually not only related
to the extra number of context switches, but is also related to the
number of instructions being executed after each context switch
as well. As shown in Table \ref{tab:cpu-instr-count}, there is
a fixed 15\% overhead of instructions up to decrypting the
\premaster. The remaining \textasciitilde13\% overhead originates
from the extra context switches and executed instructions that occur
in the design where the session keys reside within the enclave. This
overhead is not linear because our design only delegates the
execution of instructions, that were previously executed in the
untrusted component, to the trusted component. Thus, the cost
originates only from the extra instructions introduced by SGXBridge
and not by the instructions required by the SSL/TLS protocol itself.

% TODO: document keys inside/outside for the first graph TODO:
% document the second graph
\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../../main"
%%% End:
