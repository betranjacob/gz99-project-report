\documentclass[../../../main.tex]{subfiles}

\begin{document}
\label{sec:cpu-instr-analysis}
To be able to reason about the end-to-end performance impact we designed a set
of tests to measure the overhead of the enclave implementation compared to the
stock version.

% TODO: some more introduction here

% TODO: is there a better place for this?
OpenSGX comes with two options that should report the SGX instruction counts,
\textit{-i} and \textit{-{}-perf}. Unfortunately, neither of them worked
correctly so we modified OpenSGX to always return the program statistics upon
enclave termination.

\subsubsection*{Test Setup}
This benchmark consists of multiple parts: (1) we count the number of
instructions executed for vanilla NGINX + LibreSSL; (2) we measure the
instruction counts, of modified NGINX and \enclavemodel~(untrusted and trusted
components) separately; (3) we capture the number and type of SGX instructions
executed by the \enclaveprogram~during:
\begin{enumerate}[label=3\alph*)]
  \item The enclave startup.
  \item Normal operation.
\end{enumerate}

For parts (1) and (2), we capture the instruction counts using \textit{perf},
a standard linux tool for program profiling.

For part (3a), we launch the \enclaveprogram~under OpenSGX and instrumented
NGINX as usual, wait for 30 seconds to ensure the startup has fully completed
and terminate the NGINX which also terminates the \enclaveprogram.

For part (3b), we run the same workload as for parts (1) and~(2), executing
the \enclaveprogram~under OpenSGX.

The requests for (1), (2) and (3b) are generated using \Apache~Benchmark. Due
to limitation of OpenSGX performance (very long encryption/decrypton times),
we only run 50 requests with 2 concurrent connections, for both of our
designs, for each of the following ciphers:
\begin{enumerate}
  \item AES256-GCM-SHA384
  \item ECDHE-AES256-GCM-SHA384
\end{enumerate}

\subsubsection*{Results}
Table~\ref{tab:cpu-instr-count} combines the results obtained from parts (1),
(2) and (3b). It shows the sum of instructions executed over 50 requests.
Currently it also combines the instructions for RSA and ECDHE ciphers. The SGX
instructions reported exclude the the instructions executed at enclave start-up.
% TODO: the sgx column should probably include the startup sgx instructions

The SGX instruction counts detailed in Table~\ref{tab:sgx-encls} are executed
only once during start-up and are the result of part (3a) of the benchmark.

Table~\ref{tab:sgx-enclu} shows the SGX instructions executed per request. It
was obtained by subtracting the values in Table~\ref{tab:sgx-encls} from the
values obtained from part (3b) and dividing the result by number of requests.
We also verified that these match the values reported when executing only one
request.

% TODO: i think all of that was already mentioned, but maybe it'll still be
% useful
% When reporting the instructions executed per request, we ignore the cost of
% the SGX instructions executed during enclave startup, because the latter are
% executed only once, to prepare the SGX environment, and do not affect the
% application's response rate.

% TODO: i think it would be clearer if we show the instructions in millions
% need to add `%` to the change over stock column
% would be nice to have the results separated for RSA and ECDHE
% revisit the table captions
\begin{table}[H]
  \resizebox{\linewidth}{!}{ \pgfplotstabletypeset[assign column
    name/.style={/pgfplots/table/column name={\textbf{#1}}},col
    sep=comma, header=has colnames, columns/{Change over
      Stock}/.style={column name= {Change Over Stock
        (\%)}}]{results/instruction_count.csv}}
  \caption{CPU Instruction Count Analysis}
  \label{tab:cpu-instr-count}
\end{table}

\begin{table}[H]
  \center
  \footnotesize
  \pgfplotstabletypeset[assign column
    name/.style={/pgfplots/table/column name={\textbf{#1}}},col
    sep=comma, header=has colnames]{results/sgx_detail_instruction_count_s.csv}
  \caption{SGX Privileged Instructions Count}
  \label{tab:sgx-encls}
\end{table}

\begin{table}[H]
  \resizebox{\linewidth}{!}{ \pgfplotstabletypeset[assign column
    name/.style={/pgfplots/table/column name={\textbf{#1}}},col
    sep=comma, header=has colnames]
    {results/sgx_detail_instruction_count_u.csv}}
  \caption{SGX Unprivileged User Instructions Count}
  \label{tab:sgx-enclu}
\end{table}

\subsubsection*{Analysis of Results}
% TODO: i havent touched this yet, Ahmed please help
As shown in Table~\ref{tab:cpu-instr-count}, our implementation added 14.5\% of
executed instructions regarding the design where the session keys reside
outside of the enclave and 16.5\% regarding the design with session keys
reside inside the enclave. While the difference between the number of executed
instructions between the keys-outside and keys-inside are small, the proportion
of instructions executed between the untrusted and trusted component are very
different. Only 4.2\% of instructions were executed in the enclave with the
key-outside implementation but there were 97.7\% of instructions executed in
the enclave for the key-inside implementation. There could be a performance
impact on the key-inside compared to the key-outside implementation, because of
the effect of memory encryption in the enclave, as discussed in
Section~\ref{sec:mem-analysis}.

% ECDHE requires 8 pairs of context switch more than RSA regardless of the keys outside / inside -> does it agree with the design section?

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../../main"
%%% End:
