\documentclass[../main.tex]{subfiles}

\begin{document}

By utilizing the aforementioned remote-attestation process, we can provision
the trusted component  of the remote server application with an SSL private
key while making it extremely difficult* for even \textit{privileged}
processes running on the cloud provider to access the key. This is a stark
contrast to current schemes wherein the private key is merely shipped as
part of the server application to the cloud provider.

As previously highlighted in Section~\ref{sec:ssloverview}, the private key
is required by a subset of the operations executed during the handshake
step. These operations have to be executed within the trusted component, and
are invoked by the non-trusted component via an interface that we define
in this section. Note that the interface has to be carefully designed,
allowing the handshake to complete correctly while not exposing the long
term private key through an oracle.


%TODO: introduce this better to make it clear that there are 2 different
%handshakes; I only went into some detail here, definitely need more depth

Take for example an interface where the non-trusted component supplies
\texttt{(ServerRandom, ClientRandom, \{PremasterSecret\}$_K$)}. Such an
interface, while maintaining the secrecy of the private key's bits, would
allow an adversary capable of exploiting the non-trusted component to
generate the symmetric keys for previously eavesdropped sessions. Therefore,
it is no better than leaving the private key in the non-trusted component.
However, observe that it is not necessary for \texttt{ServerRandom} to be
provided by the non-trusted component, it need only be provided
by the \textit{server}.

%TODO: Cite wedge here somewhere, I do not like how I did it

We can adjust the interface so that the non-trusted component supplies
\texttt{(ClientRandom, \{PremasterSecret\}$_K$)}, both of  which are
generated by the client, and the trusted component generates a new
\texttt{ServerRandom} every time the interface is invoked. The resulting
interface ensures that, even if a previously eavesdropped
\texttt{\{PremasterSecret\}$_K$} is provided, a fresh session-key is
computed on every invocation.

%Freshness of the generated session-key has been used in [WEDGE CITATION] to
%maintain the secrecy of an SSL/TLS private key in the face of a passive
%eavesdropper how can exploit the server application's network facing
%process. We use it to secure the private key against an adversary who can
%exploit the underlying operating system and/or a malicious cloud provider.

\noindent
\\We consider two scenarios:
\begin{itemize}
	\item Session keys available to the OS
	\item Session keys hidden inside the enclave and accessible through
	encrypt/decrypt oracle
\end{itemize}

\subfile{latex-images/rsa-handshake.tex}

\paragraph{ECDHE Handshake}
TBC..

\end{document}
