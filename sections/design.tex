\documentclass[../main.tex]{subfiles}

\begin{document}

\subsection{The Threat Model}
\subfile{sections/threat-model.tex}

\subsection{System Level Design} %TODO: title is WIP

% TODO: ALL TEXT IN THIS SECTION IS WIP
Given the background and threat model detailed above, we may now
discuss the design of our system. We first describe how the system is
partitioned in a cipher agnostic manner. Then, we expand upon the
generic design, illustrating how the system handles: (1) Ciphers that
do not offer forward secrecy (2) Ciphers that offer forward secrecy.

% FIXME: I believe here we should introduce the split on the designs
% for private and session key isolation, there is more content at the
% end of this section on this which should be moved here as well.

None of our designs modify the SSL handshake itself, though we carefully
compartmentalize the protocol's execution in trusted and untrusted
components. The interface for both kind of ciphers is split into two
versions, one where only the private key of the server is protected
and one where both the private and the session keys are protected by
the enclave.

\subsubsection{Abstract Design}
By utilizing the above-detailed remote-attestation process, we can
provision the trusted component of the remote server application with
an SSL private key while making it extremely difficult for even
\textit{privileged} processes running on the cloud provider to access
the key. This is a stark contrast to current schemes wherein the
private key is merely shipped as part of the server application to the
cloud provider.

\subsubsection{Designing for Ciphers \textit{Lacking} Forward Secrecy}
As previously mentioned in Section~\ref{sec:ssloverview}, the
private key is required by a subset of the operations executed during
the handshake step. These operations have to be executed within the
trusted component, and are invoked by the non-trusted component via an
interface we define in this section. Note that the interface has
to be carefully designed, allowing the handshake to complete correctly
while not exposing the long term private key through an oracle. 

Take for example an interface where the non-trusted component supplies
\texttt{(ServerRandom, ClientRandom, \{PremasterSecret\}$_K$)}. Such
an interface, while maintaining the secrecy of the private key's bits,
would allow an adversary capable of exploiting the non-trusted
component to generate the symmetric keys for previously eavesdropped
sessions. Therefore, it is no better than leaving the private key in
the non-trusted component.  However, observe that it is not necessary
for \texttt{ServerRandom} to be provided by the non-trusted component,
it need only be provided by the \textit{server}.

% TODO: Cite wedge here somewhere, I do not like how I did it

We can adjust the interface so that the non-trusted component supplies
\texttt{ClientRandom} and \texttt{\{PremasterSecret\}$_k$}, both of
which are generated by the client, and the trusted component generates
a new \texttt{ServerRandom} every time the interface is invoked. The
resulting interface ensures that, even if a previously eavesdropped
\texttt{\{PremasterSecret\}$_K$} is provided, a fresh session-key is
computed on every invocation.

Concerning the scenario where only the server's private key is protected, the
SSL handshake begins with the client connecting to the server by sending a
ClientHello message. The \texttt{client\_random} value contained in this
message is delivered to the enclave for future key derivation. Note that,
though this value travels cleartext over the network, we have to provide the
trusted component with it as it consists a dependency for calculating the
\texttt{master\_secret}. Upon successfully feeding the enclave with
\texttt{client\_random}, the untrusted component sends a command to the enclave
requesting the generation of \texttt{server\_random} and blocks until the value
is returned (in cleartext form as well). As earlier mentioned, this ensures the
freshness of a new session and blocks an attacker who might completely own the
untrusted part of the platform from influencing session key generation. Having
received the \texttt{server\_random} value from the enclave, the server replies
to the client with a \texttt{ServerHello} message. The server blocks until it
receives the next packet from the client. The client responds with a
\texttt{ClientKeyExchange\{PremasterSecret\}$_K$} message, where \texttt{K} is
the server's public key. Leaving it intact, the server directly forwards the
encrypted message to the enclave. The code running within the enclave uses the
provisioned server's private key to decrypt \texttt{\{PremasterSecret\}$_K$}.
The latter, along with the pre-negotiated \texttt{client\_random} and
\texttt{server\_random} values are fed into a PRF in order to compute the
\texttt{master\_secret}. Recall that this interface is defined to protect only
the server's private key, thus it is safe to expose the \texttt{MasterSecret}
cleartext to the untrusted component. From now on the SSL handshake continues
without any more interactions with the enclave specific to key derivation
\footnote{Actually, there is one more interaction with the enclave upon
successful termination of an SSL handshake. This is mostly an implementation
detail regarding SSL session management and Nginx's event-driven design and is
not directly connected with the SSL/TLS protocol itself. We reason further
about this requirement in Section \ref{sec:implementation}.}.

Regarding the design where we want to protect both the server's private key
and the SSL session's key block, we augment the previously defined interface
from the point where the \texttt{\{PremasterSecret\}$_K$} is available to the
enclave. For this scenario, we do not expose the \texttt{MasterSecret} to the
untrusted component, as this would merely provide an oracle for session key
derivation to an adversary. The server asks the enclave to generate the session
key block using the pre-negotiated secrets and this key block does never leave
the trusted component. At this point, the client signals the server with a
\texttt{ChangeCipherSpec} message about transitioning to a specific CipherSpec
and the server interacts with the enclave to initialize the client's cipher
specific environment. The server now prepares for receiving the
\texttt{ClientFinished} message by calculating the digest of the handshake
messages it received so far \footnote{As defined by TLS 1.2, the digest
enclosed in the \texttt{Finished} messages does not include the
\texttt{Finished} messages themselves.}. This step entails a dependency of the
established session key, thus a context switch to the trusted environment is
required for calculating the digest of the handshake buffer. Upon receiving
the encrypted \texttt{ClientFinished} message, the server forwards the message
intact to the enclave for decryption through the decrypt interface and
calculates the MAC of the decrypted message to verify its authenticity and
integrity. If this process successfully completes, the server signals the
client for transitioning to a specific cipher and sets up the appropriate
cipher environment in the enclave as well. Finally, it asks the enclave to
calculate the digest of the handshake messages it received so far and encrypts
this digest within the encalve using the established session keys. If the
client successfully verifies all security properties of the
\texttt{ServerFinished} message, the SSL connection is considered established.
Note that, as the protocol defines, the interface used for encryption/
decryption of the \texttt{Finished} messages is the same used for encryption/
decryption of the user data travelling over the network. Thus, every subsequent
data record will be encrypted/decrypted by the same interface used for
encrypting/decrypting the \texttt{Finished} messages, with the session keys
never being exposed to the untrusted component.

% Freshness of the generated session-key has been used in [WEDGE
% CITATION] to maintain the secrecy of an SSL/TLS private key in the
% face of a passive eavesdropper how can exploit the server
% application's network facing process. We use it to secure the
% private key against an adversary who can exploit the underlying
% operating system and / or a malicious cloud provider.
\subsubsection{Designing for Ciphers \textit{Offering} Forward Secrecy}
\subfile{sections/ecdhe-handshake.tex}

\noindent
\\We consider two scenarios that slightly change the exchange of
messages with the enclave during the handshake:
\begin{itemize}
  \item Session keys available to the OS
  \item Session keys hidden inside the enclave and accessible through
    encrypt/decrypt oracle
\end{itemize}

\subfile{latex-images/rsa-handshake.tex}

\paragraph{Session keys available to the OS}

If our sole goal is to protect the long term, private key then we may
decide it is safe to keep the active sessions' keys outside of the
TCB. This allows the compromised OS to use the keys as it pleases. It
can just read them out from memory and send to a man in the middle (on
a different to compromised machine). MITM could then decrypt
previously captured traffic. This method it is possible to leak
current (and cached) sessions keys. Old, captured sessions for which
session keys have been deleted can no longer be recovered. However, if
the OS persists to be malicious it can always monitor future (current)
connections.\\

\noindent
One could prefer this option for performance reasons - such design
puts less burden on the enclave program. In particular the role of the
enclave can finish after the master secret is computed from server and
client randoms and pre-master secret. This is because a pseudo-random
function (PRF) lies between master secret and the input values so no
information can be learned about the private key. The derivation of
session keys and encryption / decryption of messages can be left
unaltered in the untrusted program and therefore less \'context\'
switches to the enclave would be required.

\paragraph{Session keys hidden within the enclave}

One may want to further protect the key material by requiring that the
session keys themselves do not leave the enclave. Instead an encrypt /
decrypt oracle interface is presented to the untrusted component. The
enclave performs the cryptographic operations using stored state
accessed by the session\_id. This prevents the compromised OS from
leaking the session keys to a different machine, but requires a more
complicated and expensive design. One can imagine that if the attacker
is leaking ton of data out of the server, it may be more easily
noticeable than if the session keys are exported outside of the server
once.\\

\noindent
If we decide to keep our session keys in the enclave apart from
providing a mechanism to transfer the cipher context we have to
additionally present an interface that would allow to sign the
handshake finish messages.\\

\noindent
To allow the trusted component to encrypt / decrypt messages we also
need to transfer the symmetric cipher context which can be done during
computation of master secret. Additionally, every time we need to pass
the initialization values such as initialization vector or nonce need
to be transferred to the enclave.\\

\noindent
The performance cost is increased since now at least 4 context
switches between untrusted and trusted processes are required for each
packet processing, i.e. 2 switches to decrypt an incoming packet and
pass plain-text back to the application and 2 to encrypt the outgoing
result after application processing (plain-text in, cipher-text out of
an enclave).\\

\noindent
Also every handshake now needs 6 (TODO: ???) more context switches
during digest update.

\subfile{latex-images/session-keys-inside.tex}

\end{document}
