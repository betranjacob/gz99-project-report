\documentclass[../main.tex]{subfiles}

\begin{document}

\subsection{The Threat Model}
\subfile{sections/threat-model.tex}

\subsection{System Level Design} %TODO: title is WIP

% TODO: ALL TEXT IN THIS SECTION IS WIP
Given the background and threat model discussed above, we may now
discuss the design of our system. We first describe how the system is
partitioned in a cipher agnostic manner. Then, we expand upon the
generic design, illustrating how the system handles: (1) Ciphers that
do not offer forward secrecy (2) Ciphers that offer forward secrecy.

\subsubsection{Abstract Design}
By utilizing the above-detailed remote-attestation process, we can
provision the trusted component of the remote server application with
an SSL private key while making it extremely difficult for even
\textit{privileged} processes running on the cloud provider to access
the key. This is a stark contrast to current schemes wherein the
private key is merely shipped as part of the server application to the
cloud provider.

\subsubsection{Designing for Ciphers \textit{Lacking} Forward Secrecy}
As previously mentioned in Section~\ref{sec:ssloverview}, the
private key is required by a subset of the operations executed during
the handshake step. These operations have to be executed within the
trusted component, and are invoked by the non-trusted component via an
interface we define in this section. Note that the interface has
to be carefully designed, allowing the handshake to complete correctly
while not exposing the long term private key through an oracle. 

Take for example an interface where the non-trusted component supplies
\texttt{(ServerRandom, ClientRandom, \{PremasterSecret\}$_K$)}. Such
an interface, while maintaining the secrecy of the private key's bits,
would allow an adversary capable of exploiting the non-trusted
component to generate the symmetric keys for previously eavesdropped
sessions. Therefore, it is no better than leaving the private key in
the non-trusted component.  However, observe that it is not necessary
for \texttt{ServerRandom} to be provided by the non-trusted component,
it need only be provided by the \textit{server}.

% TODO: Cite wedge here somewhere, I do not like how I did it

We can adjust the interface so that the non-trusted component supplies
\texttt{ClientRandom} and \texttt{\{PremasterSecret\}$_k$}, both of
which are generated by the client, and the trusted component generates
a new \texttt{ServerRandom} every time the interface is invoked. The
resulting interface ensures that, even if a previously eavesdropped
\texttt{\{PremasterSecret\}$_K$} is provided, a fresh session-key is
computed on every invocation.

% Freshness of the generated session-key has been used in [WEDGE
% CITATION] to maintain the secrecy of an SSL/TLS private key in the
% face of a passive eavesdropper how can exploit the server
% application's network facing process. We use it to secure the
% private key against an adversary who can exploit the underlying
% operating system and / or a malicious cloud provider.
\subsubsection{Designing for Ciphers \textit{Offering} Forward Secrecy}
\subfile{sections/ecdhe-handshake.tex}

\noindent
\\We consider two scenarios that slightly change the exchange of
messages with the enclave during the handshake:
\begin{itemize}
  \item Session keys available to the OS
  \item Session keys hidden inside the enclave and accessible through
    encrypt/decrypt oracle
\end{itemize}

\subfile{latex-images/rsa-handshake.tex}

\paragraph{Session keys available to the OS}

If our sole goal is to protect the long term, private key then we may
decide it is safe to keep the active sessions' keys outside of the
TCB. This allows the compromised OS to use the keys as it pleases. It
can just read them out from memory and send to a man in the middle (on
a different to compromised machine). MITM could then decrypt
previously captured traffic. This method it is possible to leak
current (and cached) sessions keys. Old, captured sessions for which
session keys have been deleted can no longer be recovered. However, if
the OS persists to be malicious it can always monitor future (current)
connections.\\

\noindent
One could prefer this option for performance reasons - such design
puts less burden on the enclave program. In particular the role of the
enclave can finish after the master secret is computed from server and
client randoms and pre-master secret. This is because a pseudo-random
function (PRF) lies between master secret and the input values so no
information can be learned about the private key. The derivation of
session keys and encryption / decryption of messages can be left
unaltered in the untrusted program and therefore less \'context\'
switches to the enclave would be required.

\paragraph{Session keys hidden within the enclave}

One may want to further protect the key material by requiring that the
session keys themselves do not leave the enclave. Instead an encrypt /
decrypt oracle interface is presented to the untrusted component. The
enclave performs the cryptographic operations using stored state
accessed by the session\_id. This prevents the compromised OS from
leaking the session keys to a different machine, but requires a more
complicated and expensive design. One can imagine that if the attacker
is leaking ton of data out of the server, it may be more easily
noticeable than if the session keys are exported outside of the server
once.\\

\noindent
If we decide to keep our session keys in the enclave apart from
providing a mechanism to transfer the cipher context we have to
additionally present an interface that would allow to sign the
handshake finish messages.\\

\noindent
To allow the trusted component to encrypt / decrypt messages we also
need to transfer the symmetric cipher context which can be done during
computation of master secret. Additionally, every time we need to pass
the initialization values such as initialization vector or nonce need
to be transferred to the enclave.\\

\noindent
The performance cost is increased since now at least 4 context
switches between untrusted and trusted processes are required for each
packet processing, i.e. 2 switches to decrypt an incoming packet and
pass plain-text back to the application and 2 to encrypt the outgoing
result after application processing (plain-text in, cipher-text out of
an enclave).\\

\noindent
Also every handshake now needs 6 (TODO: ???) more context switches
during digest update.

\subfile{latex-images/session-keys-inside.tex}

\end{document}
