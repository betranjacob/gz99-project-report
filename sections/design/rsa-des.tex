\documentclass[../../main.tex]{subfiles}

\begin{document}
As previously mentioned in Section~\ref{sec:ssloverview}, the private
key is required by a subset of the operations executed during the
handshake step. These operations have to be executed within the
trusted component, and are invoked by the non-trusted component via an
interface we define in this section. Note that the interface has to be
carefully designed, allowing the handshake to complete correctly while
not exposing the long term private key through an oracle.

Take for example an interface where the non-trusted component supplies
\texttt{(ServerRandom, ClientRandom, \{PremasterSecret\}$_K$)}. Such
an interface, while maintaining the secrecy of the private key's bits,
would allow an adversary capable of exploiting the non-trusted
component to generate the symmetric keys for previously eavesdropped
sessions. Therefore, it is no better than leaving the private key in
the non-trusted component.  However, observe that it is not necessary
for \texttt{ServerRandom} to be provided by the non-trusted component,
it need only be provided by the \textit{server}.

% TODO: Cite wedge here somewhere, I do not like how I did it

We can adjust the interface so that the non-trusted component supplies
\texttt{ClientRandom} and \texttt{\{PremasterSecret\}$_k$}, both of
which are generated by the client, and the trusted component generates
a new \texttt{ServerRandom} every time the interface is invoked. The
resulting interface ensures that, even if a previously eavesdropped
\texttt{\{PremasterSecret\}$_K$} is provided, a fresh session-key is
computed on every invocation.

Concerning the scenario where only the server's private key is
protected, the SSL handshake begins with the client connecting to the
server by sending a ClientHello message. The \texttt{client\_random}
value contained in this message is delivered to the enclave for future
key derivation. Note that, though this value travels cleartext over
the network, we have to provide the trusted component with it as it
consists a dependency for calculating the
\texttt{master\_secret}. Upon successfully feeding the enclave with
\texttt{client\_random}, the untrusted component sends a command to
the enclave requesting the generation of \texttt{server\_random} and
blocks until the value is returned (in cleartext form as well). As
earlier mentioned, this ensures the freshness of a new session and
blocks an attacker who might completely own the untrusted part of the
platform from influencing session key generation. Having received the
\texttt{server\_random} value from the enclave, the server replies to
the client with a \texttt{ServerHello} message. The server blocks
until it receives the next packet from the client. The client responds
with a \texttt{ClientKeyExchange\{PremasterSecret\}$_K$} message,
where \texttt{K} is the server's public key. Leaving it intact, the
server directly forwards the encrypted message to the enclave. The
code running within the enclave uses the provisioned server's private
key to decrypt \texttt{\{PremasterSecret\}$_K$}.  The latter, along
with the pre-negotiated \texttt{client\_random} and
\texttt{server\_random} values are fed into a PRF in order to compute
the \texttt{master\_secret}. Recall that this interface is defined to
protect only the server's private key, thus it is safe to expose the
\texttt{MasterSecret} cleartext to the untrusted component. From now
on the SSL handshake continues without any more interactions with the
enclave specific to key derivation \footnote{Actually, there is one
more interaction with the enclave upon successful termination of an
SSL handshake. This is mostly an implementation detail regarding SSL
session management and Nginx's event-driven design and is not directly
connected with the SSL/TLS protocol itself. We reason further about
this requirement in Section \ref{sec:implementation}.}.

Regarding the design where we want to protect both the server's
private key and the SSL session's key block, we augment the previously
defined interface from the point where the
\texttt{\{PremasterSecret\}$_K$} is available to the enclave. For this
scenario, we do not expose the \texttt{MasterSecret} to the untrusted
component, as this would merely provide an oracle for session key
derivation to an adversary. The server asks the enclave to generate
the session key block using the pre-negotiated secrets and this key
block does never leave the trusted component. At this point, the
client signals the server with a \texttt{ChangeCipherSpec} message
about transitioning to a specific CipherSpec and the server interacts
with the enclave to initialize the client's cipher specific
environment. The server now prepares for receiving the
\texttt{ClientFinished} message by calculating the digest of the
handshake messages it received so far \footnote{As defined by TLS 1.2,
the digest enclosed in the \texttt{Finished} messages does not include
the \texttt{Finished} messages themselves.}. This step entails a
dependency of the established session key, thus a context switch to
the trusted environment is required for calculating the digest of the
handshake buffer. Upon receiving the encrypted \texttt{ClientFinished}
message, the server forwards the message intact to the enclave for
decryption through the decrypt interface and calculates the MAC of the
decrypted message to verify its authenticity and integrity. If this
process successfully completes, the server signals the client for
transitioning to a specific cipher and sets up the appropriate cipher
environment in the enclave as well. Finally, it asks the enclave to
calculate the digest of the handshake messages it received so far and
encrypts this digest within the encalve using the established session
keys. If the client successfully verifies all security properties of
the \texttt{ServerFinished} message, the SSL connection is considered
established.  Note that, as the protocol defines, the interface used
for encryption/ decryption of the \texttt{Finished} messages is the
same used for encryption/ decryption of the user data travelling over
the network. Thus, every subsequent data record will be
encrypted/decrypted by the same interface used for
encrypting/decrypting the \texttt{Finished} messages, with the session
keys never being exposed to the untrusted component.
% Freshness of the generated session-key has been used in [WEDGE
% CITATION] to maintain the secrecy of an SSL/TLS private key in the
% face of a passive eavesdropper how can exploit the server
% application's network facing process. We use it to secure the
% private key against an adversary who can exploit the underlying
% operating system and / or a malicious cloud provider.
\end{document}