\documentclass[../../main.tex]{subfiles}

\begin{document}

Regarding the design where we want to protect both the server's
private key and the SSL session's key block, we augment the previously
defined interface from the point where the
\texttt{\{PremasterSecret\}$_K$} is available to the enclave. For this
scenario, we do not expose the \texttt{MasterSecret} to the untrusted
component, as this would merely provide an oracle for session key
derivation to an adversary. The server asks the enclave to generate
the session key block using the pre-negotiated secrets and this key
block does never leave the trusted component. At this point, the
client signals the server with a \texttt{ChangeCipherSpec} message
about transitioning to a specific CipherSpec and the server interacts
with the enclave to initialize the client's cipher specific
environment. The server now prepares for receiving the
\texttt{ClientFinished} message by calculating the digest of the
handshake messages it received so far \footnote{As defined by TLS 1.2,
  the digest enclosed in the \texttt{Finished} messages does not
  include the \texttt{Finished} messages themselves.}. This step
entails a dependency of the established session key, thus a context
switch to the trusted environment is required for calculating the
digest of the handshake buffer. Upon receiving the encrypted
\texttt{ClientFinished} message, the server forwards the message
intact to the enclave for decryption through the decrypt interface and
calculates the MAC of the decrypted message to verify its authenticity
and integrity. If this process successfully completes, the server
signals the client for transitioning to a specific cipher and sets up
the appropriate cipher environment in the enclave as well. Finally, it
asks the enclave to calculate the digest of the handshake messages it
received so far and encrypts this digest within the encalve using the
established session keys. If the client successfully verifies all
security properties of the \texttt{ServerFinished} message, the SSL
connection is considered established. Note that, as the protocol
defines, the interface used for encryption/ decryption of the
\texttt{Finished} messages is the same used for encryption/ decryption
of the user data travelling over the network. Thus, every subsequent
data record will be encrypted/decrypted by the same interface used for
encrypting/decrypting the \texttt{Finished} messages, with the session
keys never being exposed to the untrusted component.

\paragraph{Session keys available to the OS}

If our sole goal is to protect the long term, private key then we may
decide it is safe to keep the active sessions' keys outside of the
TCB. This allows the compromised OS to use the keys as it pleases. It
can just read them out from memory and send to a man in the middle (on
a different to compromised machine). MITM could then decrypt
previously captured traffic. This method it is possible to leak
current (and cached) sessions keys. Old, captured sessions for which
session keys have been deleted can no longer be recovered. However, if
the OS persists to be malicious it can always monitor future (current)
connections.\\

\noindent One could prefer this option for performance reasons - such
design puts less burden on the enclave program. In particular the role
of the enclave can finish after the master secret is computed from
server and client randoms and pre-master secret. This is because a
pseudo-random function (PRF) lies between master secret and the input
values so no information can be learned about the private key. The
derivation of session keys and encryption / decryption of messages can
be left unaltered in the untrusted program and therefore less
\'context\' switches to the enclave would be required.

\paragraph{Session keys hidden within the enclave}

One may want to further protect the key material by requiring that the
session keys themselves do not leave the enclave. Instead an encrypt /
decrypt oracle interface is presented to the untrusted component. The
enclave performs the cryptographic operations using stored state
accessed by the session\_id. This prevents the compromised OS from
leaking the session keys to a different machine, but requires a more
complicated and expensive design. One can imagine that if the attacker
is leaking ton of data out of the server, it may be more easily
noticeable than if the session keys are exported outside of the server
once.\\

\noindent If we decide to keep our session keys in the enclave apart
from providing a mechanism to transfer the cipher context we have to
additionally present an interface that would allow to sign the
handshake finish messages.\\

\noindent To allow the trusted component to encrypt / decrypt messages
we also need to transfer the symmetric cipher context which can be
done during computation of master secret. Additionally, every time we
need to pass the initialization values such as initialization vector
or nonce need to be transferred to the enclave.\\

\noindent The performance cost is increased since now at least 4
context switches between untrusted and trusted processes are required
for each packet processing, i.e. 2 switches to decrypt an incoming
packet and pass plain-text back to the application and 2 to encrypt
the outgoing result after application processing (plain-text in,
cipher-text out of an enclave).\\

\noindent Also every handshake now needs 6 (TODO: ???) more context
switches during digest update.

\end{document}
